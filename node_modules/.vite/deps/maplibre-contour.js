import "./chunk-76J2PTFD.js";

// node_modules/maplibre-contour/dist/index.mjs
var shared;
var worker;
var mlcontour;
function define(_, chunk) {
  if (!shared) {
    shared = chunk;
  } else if (!worker) {
    worker = chunk;
  } else {
    var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
    var sharedChunk = {};
    shared(sharedChunk);
    mlcontour = chunk(sharedChunk);
    if (typeof window !== "undefined") {
      mlcontour.workerUrl = window.URL.createObjectURL(
        new Blob([workerBundleString], { type: "text/javascript" })
      );
    }
  }
}
define(["exports"], function(exports) {
  "use strict";
  class Fragment {
    constructor(start, end) {
      this.start = start;
      this.end = end;
      this.points = [];
      this.append = this.append.bind(this);
      this.prepend = this.prepend.bind(this);
    }
    append(x, y) {
      this.points.push(Math.round(x), Math.round(y));
    }
    prepend(x, y) {
      this.points.splice(0, 0, Math.round(x), Math.round(y));
    }
    lineString() {
      return this.toArray();
    }
    isEmpty() {
      return this.points.length < 2;
    }
    appendFragment(other) {
      this.points.push(...other.points);
      this.end = other.end;
    }
    toArray() {
      return this.points;
    }
  }
  const CASES = [
    [],
    [
      [
        [1, 2],
        [0, 1]
      ]
    ],
    [
      [
        [2, 1],
        [1, 2]
      ]
    ],
    [
      [
        [2, 1],
        [0, 1]
      ]
    ],
    [
      [
        [1, 0],
        [2, 1]
      ]
    ],
    [
      [
        [1, 2],
        [0, 1]
      ],
      [
        [1, 0],
        [2, 1]
      ]
    ],
    [
      [
        [1, 0],
        [1, 2]
      ]
    ],
    [
      [
        [1, 0],
        [0, 1]
      ]
    ],
    [
      [
        [0, 1],
        [1, 0]
      ]
    ],
    [
      [
        [1, 2],
        [1, 0]
      ]
    ],
    [
      [
        [0, 1],
        [1, 0]
      ],
      [
        [2, 1],
        [1, 2]
      ]
    ],
    [
      [
        [2, 1],
        [1, 0]
      ]
    ],
    [
      [
        [0, 1],
        [2, 1]
      ]
    ],
    [
      [
        [1, 2],
        [2, 1]
      ]
    ],
    [
      [
        [0, 1],
        [1, 2]
      ]
    ],
    []
  ];
  function index(width, x, y, point) {
    x = x * 2 + point[0];
    y = y * 2 + point[1];
    return x + y * (width + 1) * 2;
  }
  function ratio(a, b, c) {
    return (b - a) / (c - a);
  }
  function generateIsolines(interval, tile, extent = 4096, buffer = 1) {
    if (!interval) {
      return {};
    }
    const multiplier = extent / (tile.width - 1);
    let tld, trd, bld, brd;
    let r, c;
    const segments = {};
    const fragmentByStartByLevel = /* @__PURE__ */ new Map();
    const fragmentByEndByLevel = /* @__PURE__ */ new Map();
    function interpolate(point, threshold, accept) {
      if (point[0] === 0) {
        accept(multiplier * (c - 1), multiplier * (r - ratio(bld, threshold, tld)));
      } else if (point[0] === 2) {
        accept(multiplier * c, multiplier * (r - ratio(brd, threshold, trd)));
      } else if (point[1] === 0) {
        accept(multiplier * (c - ratio(trd, threshold, tld)), multiplier * (r - 1));
      } else {
        accept(multiplier * (c - ratio(brd, threshold, bld)), multiplier * r);
      }
    }
    for (r = 1 - buffer; r < tile.height + buffer; r++) {
      trd = tile.get(0, r - 1);
      brd = tile.get(0, r);
      let minR = Math.min(trd, brd);
      let maxR = Math.max(trd, brd);
      for (c = 1 - buffer; c < tile.width + buffer; c++) {
        tld = trd;
        bld = brd;
        trd = tile.get(c, r - 1);
        brd = tile.get(c, r);
        const minL = minR;
        const maxL = maxR;
        minR = Math.min(trd, brd);
        maxR = Math.max(trd, brd);
        if (isNaN(tld) || isNaN(trd) || isNaN(brd) || isNaN(bld)) {
          continue;
        }
        const min = Math.min(minL, minR);
        const max = Math.max(maxL, maxR);
        const start = Math.ceil(min / interval) * interval;
        const end = Math.floor(max / interval) * interval;
        for (let threshold = start; threshold <= end; threshold += interval) {
          const tl = tld > threshold;
          const tr = trd > threshold;
          const bl = bld > threshold;
          const br = brd > threshold;
          for (const segment of CASES[(tl ? 8 : 0) | (tr ? 4 : 0) | (br ? 2 : 0) | (bl ? 1 : 0)]) {
            let fragmentByStart = fragmentByStartByLevel.get(threshold);
            if (!fragmentByStart)
              fragmentByStartByLevel.set(threshold, fragmentByStart = /* @__PURE__ */ new Map());
            let fragmentByEnd = fragmentByEndByLevel.get(threshold);
            if (!fragmentByEnd)
              fragmentByEndByLevel.set(threshold, fragmentByEnd = /* @__PURE__ */ new Map());
            const start2 = segment[0];
            const end2 = segment[1];
            const startIndex = index(tile.width, c, r, start2);
            const endIndex = index(tile.width, c, r, end2);
            let f, g;
            if (f = fragmentByEnd.get(startIndex)) {
              fragmentByEnd.delete(startIndex);
              if (g = fragmentByStart.get(endIndex)) {
                fragmentByStart.delete(endIndex);
                if (f === g) {
                  interpolate(end2, threshold, f.append);
                  if (!f.isEmpty()) {
                    let list = segments[threshold];
                    if (!list) {
                      segments[threshold] = list = [];
                    }
                    list.push(f.lineString());
                  }
                } else {
                  f.appendFragment(g);
                  fragmentByEnd.set(f.end = g.end, f);
                }
              } else {
                interpolate(end2, threshold, f.append);
                fragmentByEnd.set(f.end = endIndex, f);
              }
            } else if (f = fragmentByStart.get(endIndex)) {
              fragmentByStart.delete(endIndex);
              interpolate(start2, threshold, f.prepend);
              fragmentByStart.set(f.start = startIndex, f);
            } else {
              const newFrag = new Fragment(startIndex, endIndex);
              interpolate(start2, threshold, newFrag.append);
              interpolate(end2, threshold, newFrag.append);
              fragmentByStart.set(startIndex, newFrag);
              fragmentByEnd.set(endIndex, newFrag);
            }
          }
        }
      }
    }
    for (const [level, fragmentByStart] of fragmentByStartByLevel.entries()) {
      let list = null;
      for (const value of fragmentByStart.values()) {
        if (!value.isEmpty()) {
          if (list == null) {
            list = segments[level] || (segments[level] = []);
          }
          list.push(value.lineString());
        }
      }
    }
    return segments;
  }
  let num = 0;
  class AsyncCache {
    constructor(maxSize = 100) {
      this.size = () => this.items.size;
      this.get = (key, supplier) => this.getCancelable(key, (key2) => ({
        value: supplier(key2),
        cancel: () => {
        }
      })).value;
      this.getCancelable = (key, supplier) => {
        let result = this.items.get(key);
        if (!result) {
          const value2 = supplier(key);
          result = {
            cancel: value2.cancel,
            item: value2.value,
            lastUsed: ++num,
            waiting: 1
          };
          this.items.set(key, result);
          this.prune();
        } else {
          result.lastUsed = ++num;
          result.waiting++;
        }
        const items = this.items;
        const value = result.item.then((r) => r, (e) => {
          items.delete(key);
          return Promise.reject(e);
        });
        let canceled = false;
        return {
          value,
          cancel: () => {
            if (result && result.cancel && !canceled) {
              canceled = true;
              if (--result.waiting <= 0) {
                result.cancel();
                items.delete(key);
              }
            }
          }
        };
      };
      this.clear = () => this.items.clear();
      this.maxSize = maxSize;
      this.items = /* @__PURE__ */ new Map();
    }
    prune() {
      if (this.items.size > this.maxSize) {
        let minKey;
        let minUse = Infinity;
        this.items.forEach((value, key) => {
          if (value.lastUsed < minUse) {
            minUse = value.lastUsed;
            minKey = key;
          }
        });
        if (typeof minKey !== "undefined") {
          this.items.delete(minKey);
        }
      }
    }
  }
  function sortedEntries(object) {
    const entries = Object.entries(object);
    entries.sort(([a], [b]) => a < b ? -1 : a > b ? 1 : 0);
    return entries;
  }
  function encodeThresholds(thresholds) {
    return sortedEntries(thresholds).map(([key, value]) => [key, ...typeof value === "number" ? [value] : value].join("*")).join("~");
  }
  function decodeThresholds(thresholds) {
    return Object.fromEntries(thresholds.split("~").map((part) => part.split("*").map(Number)).map(([key, ...values]) => [key, values]));
  }
  function encodeOptions({ thresholds, ...rest }) {
    return sortedEntries({ thresholds: encodeThresholds(thresholds), ...rest }).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
  }
  function decodeOptions(options) {
    return Object.fromEntries(options.replace(/^.*\?/, "").split("&").map((part) => {
      const parts = part.split("=").map(decodeURIComponent);
      const k = parts[0];
      let v = parts[1];
      switch (k) {
        case "thresholds":
          v = decodeThresholds(v);
          break;
        case "extent":
        case "multiplier":
        case "overzoom":
        case "buffer":
          v = Number(v);
      }
      return [k, v];
    }));
  }
  function encodeIndividualOptions(options) {
    return sortedEntries(options).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join(",");
  }
  function getOptionsForZoom(options, zoom) {
    const { thresholds, ...rest } = options;
    let levels = [];
    let maxLessThanOrEqualTo = -Infinity;
    Object.entries(thresholds).forEach(([zString, value]) => {
      const z = Number(zString);
      if (z <= zoom && z > maxLessThanOrEqualTo) {
        maxLessThanOrEqualTo = z;
        levels = typeof value === "number" ? [value] : value;
      }
    });
    return {
      levels,
      ...rest
    };
  }
  function map({ cancel, value }, mapper) {
    return { cancel, value: value.then(mapper) };
  }
  function copy(src) {
    const dst = new ArrayBuffer(src.byteLength);
    new Uint8Array(dst).set(new Uint8Array(src));
    return dst;
  }
  function prepareDemTile(promise, copy2) {
    return map(promise, ({ data, ...rest }) => {
      let newData = data;
      if (copy2) {
        newData = new Float32Array(data.length);
        newData.set(data);
      }
      return { ...rest, data: newData, transferrables: [newData.buffer] };
    });
  }
  function prepareContourTile(promise) {
    return map(promise, ({ arrayBuffer }) => {
      const clone = copy(arrayBuffer);
      return {
        arrayBuffer: clone,
        transferrables: [clone]
      };
    });
  }
  let supportsOffscreenCanvas = null;
  function offscreenCanvasSupported() {
    if (supportsOffscreenCanvas == null) {
      supportsOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap === "function";
    }
    return supportsOffscreenCanvas || false;
  }
  function withTimeout(timeoutMs, { value, cancel }) {
    let reject = () => {
    };
    const timeout = setTimeout(() => {
      cancel();
      reject(new Error("timed out"));
    }, timeoutMs);
    const cancelPromise = new Promise((_, rej) => {
      reject = rej;
    });
    return {
      value: Promise.race([
        cancelPromise,
        (async () => {
          try {
            return await value;
          } finally {
            clearTimeout(timeout);
          }
        })()
      ]),
      cancel: () => {
        clearTimeout(timeout);
        cancel();
      }
    };
  }
  let offscreenCanvas;
  let offscreenContext;
  let canvas;
  let canvasContext;
  function decodeImageModern(blob, encoding) {
    let canceled = false;
    const promise = createImageBitmap(blob).then((img) => {
      if (canceled)
        return null;
      if (!offscreenCanvas) {
        offscreenCanvas = new OffscreenCanvas(img.width, img.height);
        offscreenContext = offscreenCanvas.getContext("2d", {
          willReadFrequently: true
        });
      }
      return getElevations(img, encoding, offscreenCanvas, offscreenContext);
    });
    return {
      value: promise,
      cancel: () => {
        canceled = true;
      }
    };
  }
  function decodeImageOld(blob, encoding) {
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvasContext = canvas.getContext("2d", {
        willReadFrequently: true
      });
    }
    let canceled = false;
    const img = new Image();
    const value = new Promise((resolve, reject) => {
      img.onload = () => {
        if (!canceled)
          resolve(img);
        URL.revokeObjectURL(img.src);
        img.onload = null;
      };
      img.onerror = () => reject(new Error("Could not load image."));
      img.src = blob.size ? URL.createObjectURL(blob) : "";
    }).then((img2) => getElevations(img2, encoding, canvas, canvasContext));
    return {
      value,
      cancel: () => {
        canceled = true;
        img.src = "";
      }
    };
  }
  function decodeImageOnMainThread(blob, encoding) {
    return self.actor.send("decodeImage", [], void 0, blob, encoding);
  }
  function isWorker() {
    return (
      // @ts-ignore
      typeof WorkerGlobalScope !== "undefined" && typeof self !== "undefined" && // @ts-ignore
      self instanceof WorkerGlobalScope
    );
  }
  const defaultDecoder = offscreenCanvasSupported() ? decodeImageModern : isWorker() ? decodeImageOnMainThread : decodeImageOld;
  function getElevations(img, encoding, canvas2, canvasContext2) {
    canvas2.width = img.width;
    canvas2.height = img.height;
    if (!canvasContext2)
      throw new Error("failed to get context");
    canvasContext2.drawImage(img, 0, 0, img.width, img.height);
    const rgba = canvasContext2.getImageData(0, 0, img.width, img.height).data;
    return decodeParsedImage(img.width, img.height, encoding, rgba);
  }
  function decodeParsedImage(width, height, encoding, input) {
    const decoder = encoding === "mapbox" ? (r, g, b) => -1e4 + (r * 256 * 256 + g * 256 + b) * 0.1 : (r, g, b) => r * 256 + g + b / 256 - 32768;
    const data = new Float32Array(width * height);
    for (let i = 0; i < input.length; i += 4) {
      data[i / 4] = decoder(input[i], input[i + 1], input[i + 2]);
    }
    return { width, height, data };
  }
  const MIN_VALID_M = -12e3;
  const MAX_VALID_M = 9e3;
  function defaultIsValid(number) {
    return !isNaN(number) && number >= MIN_VALID_M && number <= MAX_VALID_M;
  }
  class HeightTile {
    constructor(width, height, get) {
      this.split = (subz, subx, suby) => {
        if (subz === 0)
          return this;
        const by = 1 << subz;
        const dx = subx * this.width / by;
        const dy = suby * this.height / by;
        return new HeightTile(this.width / by, this.height / by, (x, y) => this.get(x + dx, y + dy));
      };
      this.subsamplePixelCenters = (factor) => {
        const lerp = (a, b, f) => isNaN(a) ? b : isNaN(b) ? a : a + (b - a) * f;
        if (factor <= 1)
          return this;
        const sub = 0.5 - 1 / (2 * factor);
        const blerper = (x, y) => {
          const dx = x / factor - sub;
          const dy = y / factor - sub;
          const ox = Math.floor(dx);
          const oy = Math.floor(dy);
          const a = this.get(ox, oy);
          const b = this.get(ox + 1, oy);
          const c = this.get(ox, oy + 1);
          const d = this.get(ox + 1, oy + 1);
          const fx = dx - ox;
          const fy = dy - oy;
          const top = lerp(a, b, fx);
          const bottom = lerp(c, d, fx);
          return lerp(top, bottom, fy);
        };
        return new HeightTile(this.width * factor, this.height * factor, blerper);
      };
      this.averagePixelCentersToGrid = (radius = 1) => new HeightTile(this.width + 1, this.height + 1, (x, y) => {
        let sum = 0, count = 0, v = 0;
        for (let newX = x - radius; newX < x + radius; newX++) {
          for (let newY = y - radius; newY < y + radius; newY++) {
            if (!isNaN(v = this.get(newX, newY))) {
              count++;
              sum += v;
            }
          }
        }
        return count === 0 ? NaN : sum / count;
      });
      this.scaleElevation = (multiplier) => multiplier === 1 ? this : new HeightTile(this.width, this.height, (x, y) => this.get(x, y) * multiplier);
      this.materialize = (buffer = 2) => {
        const stride = this.width + 2 * buffer;
        const data = new Float32Array(stride * (this.height + 2 * buffer));
        let idx = 0;
        for (let y = -buffer; y < this.height + buffer; y++) {
          for (let x = -buffer; x < this.width + buffer; x++) {
            data[idx++] = this.get(x, y);
          }
        }
        return new HeightTile(this.width, this.height, (x, y) => data[(y + buffer) * stride + x + buffer]);
      };
      this.get = get;
      this.width = width;
      this.height = height;
    }
    /** Construct a height tile from raw DEM pixel values */
    static fromRawDem(demTile) {
      return new HeightTile(demTile.width, demTile.height, (x, y) => {
        const value = demTile.data[y * demTile.width + x];
        return defaultIsValid(value) ? value : NaN;
      });
    }
    /**
     * Construct a height tile from a DEM tile plus it's 8 neighbors, so that
     * you can request `x` or `y` outside the bounds of the original tile.
     *
     * @param neighbors An array containing tiles: `[nw, n, ne, w, c, e, sw, s, se]`
     */
    static combineNeighbors(neighbors) {
      if (neighbors.length !== 9) {
        throw new Error("Must include a tile plus 8 neighbors");
      }
      const mainTile = neighbors[4];
      if (!mainTile) {
        return void 0;
      }
      const width = mainTile.width;
      const height = mainTile.height;
      return new HeightTile(width, height, (x, y) => {
        let gridIdx = 0;
        if (y < 0) {
          y += height;
        } else if (y < height) {
          gridIdx += 3;
        } else {
          y -= height;
          gridIdx += 6;
        }
        if (x < 0) {
          x += width;
        } else if (x < width) {
          gridIdx += 1;
        } else {
          x -= width;
          gridIdx += 2;
        }
        const grid = neighbors[gridIdx];
        return grid ? grid.get(x, y) : NaN;
      });
    }
  }
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var ieee754$1 = {};
  ieee754$1.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754$1.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i - d] |= s * 128;
  };
  var pbf = Pbf;
  var ieee754 = ieee754$1;
  function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
  }
  Pbf.Varint = 0;
  Pbf.Fixed64 = 1;
  Pbf.Bytes = 2;
  Pbf.Fixed32 = 5;
  var SHIFT_LEFT_32 = (1 << 16) * (1 << 16), SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
  var TEXT_DECODER_MIN_LENGTH = 12;
  var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
  Pbf.prototype = {
    destroy: function() {
      this.buf = null;
    },
    // === READING =================================================================
    readFields: function(readField, result, end) {
      end = end || this.length;
      while (this.pos < end) {
        var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
        this.type = val & 7;
        readField(tag, result, this);
        if (this.pos === startPos)
          this.skip(val);
      }
      return result;
    },
    readMessage: function(readField, result) {
      return this.readFields(readField, result, this.readVarint() + this.pos);
    },
    readFixed32: function() {
      var val = readUInt32(this.buf, this.pos);
      this.pos += 4;
      return val;
    },
    readSFixed32: function() {
      var val = readInt32(this.buf, this.pos);
      this.pos += 4;
      return val;
    },
    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
    readFixed64: function() {
      var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
      this.pos += 8;
      return val;
    },
    readSFixed64: function() {
      var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
      this.pos += 8;
      return val;
    },
    readFloat: function() {
      var val = ieee754.read(this.buf, this.pos, true, 23, 4);
      this.pos += 4;
      return val;
    },
    readDouble: function() {
      var val = ieee754.read(this.buf, this.pos, true, 52, 8);
      this.pos += 8;
      return val;
    },
    readVarint: function(isSigned) {
      var buf = this.buf, val, b;
      b = buf[this.pos++];
      val = b & 127;
      if (b < 128)
        return val;
      b = buf[this.pos++];
      val |= (b & 127) << 7;
      if (b < 128)
        return val;
      b = buf[this.pos++];
      val |= (b & 127) << 14;
      if (b < 128)
        return val;
      b = buf[this.pos++];
      val |= (b & 127) << 21;
      if (b < 128)
        return val;
      b = buf[this.pos];
      val |= (b & 15) << 28;
      return readVarintRemainder(val, isSigned, this);
    },
    readVarint64: function() {
      return this.readVarint(true);
    },
    readSVarint: function() {
      var num2 = this.readVarint();
      return num2 % 2 === 1 ? (num2 + 1) / -2 : num2 / 2;
    },
    readBoolean: function() {
      return Boolean(this.readVarint());
    },
    readString: function() {
      var end = this.readVarint() + this.pos;
      var pos = this.pos;
      this.pos = end;
      if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
        return readUtf8TextDecoder(this.buf, pos, end);
      }
      return readUtf8(this.buf, pos, end);
    },
    readBytes: function() {
      var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
      this.pos = end;
      return buffer;
    },
    // verbose for performance reasons; doesn't affect gzipped size
    readPackedVarint: function(arr, isSigned) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readVarint(isSigned));
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readVarint(isSigned));
      return arr;
    },
    readPackedSVarint: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readSVarint());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readSVarint());
      return arr;
    },
    readPackedBoolean: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readBoolean());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readBoolean());
      return arr;
    },
    readPackedFloat: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readFloat());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readFloat());
      return arr;
    },
    readPackedDouble: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readDouble());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readDouble());
      return arr;
    },
    readPackedFixed32: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readFixed32());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readFixed32());
      return arr;
    },
    readPackedSFixed32: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readSFixed32());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readSFixed32());
      return arr;
    },
    readPackedFixed64: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readFixed64());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readFixed64());
      return arr;
    },
    readPackedSFixed64: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readSFixed64());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readSFixed64());
      return arr;
    },
    skip: function(val) {
      var type = val & 7;
      if (type === Pbf.Varint)
        while (this.buf[this.pos++] > 127) {
        }
      else if (type === Pbf.Bytes)
        this.pos = this.readVarint() + this.pos;
      else if (type === Pbf.Fixed32)
        this.pos += 4;
      else if (type === Pbf.Fixed64)
        this.pos += 8;
      else
        throw new Error("Unimplemented type: " + type);
    },
    // === WRITING =================================================================
    writeTag: function(tag, type) {
      this.writeVarint(tag << 3 | type);
    },
    realloc: function(min) {
      var length = this.length || 16;
      while (length < this.pos + min)
        length *= 2;
      if (length !== this.length) {
        var buf = new Uint8Array(length);
        buf.set(this.buf);
        this.buf = buf;
        this.length = length;
      }
    },
    finish: function() {
      this.length = this.pos;
      this.pos = 0;
      return this.buf.subarray(0, this.length);
    },
    writeFixed32: function(val) {
      this.realloc(4);
      writeInt32(this.buf, val, this.pos);
      this.pos += 4;
    },
    writeSFixed32: function(val) {
      this.realloc(4);
      writeInt32(this.buf, val, this.pos);
      this.pos += 4;
    },
    writeFixed64: function(val) {
      this.realloc(8);
      writeInt32(this.buf, val & -1, this.pos);
      writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
      this.pos += 8;
    },
    writeSFixed64: function(val) {
      this.realloc(8);
      writeInt32(this.buf, val & -1, this.pos);
      writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
      this.pos += 8;
    },
    writeVarint: function(val) {
      val = +val || 0;
      if (val > 268435455 || val < 0) {
        writeBigVarint(val, this);
        return;
      }
      this.realloc(4);
      this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
      if (val <= 127)
        return;
      this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
      if (val <= 127)
        return;
      this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
      if (val <= 127)
        return;
      this.buf[this.pos++] = val >>> 7 & 127;
    },
    writeSVarint: function(val) {
      this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },
    writeBoolean: function(val) {
      this.writeVarint(Boolean(val));
    },
    writeString: function(str) {
      str = String(str);
      this.realloc(str.length * 4);
      this.pos++;
      var startPos = this.pos;
      this.pos = writeUtf8(this.buf, str, this.pos);
      var len = this.pos - startPos;
      if (len >= 128)
        makeRoomForExtraLength(startPos, len, this);
      this.pos = startPos - 1;
      this.writeVarint(len);
      this.pos += len;
    },
    writeFloat: function(val) {
      this.realloc(4);
      ieee754.write(this.buf, val, this.pos, true, 23, 4);
      this.pos += 4;
    },
    writeDouble: function(val) {
      this.realloc(8);
      ieee754.write(this.buf, val, this.pos, true, 52, 8);
      this.pos += 8;
    },
    writeBytes: function(buffer) {
      var len = buffer.length;
      this.writeVarint(len);
      this.realloc(len);
      for (var i = 0; i < len; i++)
        this.buf[this.pos++] = buffer[i];
    },
    writeRawMessage: function(fn, obj) {
      this.pos++;
      var startPos = this.pos;
      fn(obj, this);
      var len = this.pos - startPos;
      if (len >= 128)
        makeRoomForExtraLength(startPos, len, this);
      this.pos = startPos - 1;
      this.writeVarint(len);
      this.pos += len;
    },
    writeMessage: function(tag, fn, obj) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeRawMessage(fn, obj);
    },
    writePackedVarint: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedVarint, arr);
    },
    writePackedSVarint: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedSVarint, arr);
    },
    writePackedBoolean: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedBoolean, arr);
    },
    writePackedFloat: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedFloat, arr);
    },
    writePackedDouble: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedDouble, arr);
    },
    writePackedFixed32: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedFixed32, arr);
    },
    writePackedSFixed32: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedSFixed32, arr);
    },
    writePackedFixed64: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedFixed64, arr);
    },
    writePackedSFixed64: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedSFixed64, arr);
    },
    writeBytesField: function(tag, buffer) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
      this.writeTag(tag, Pbf.Varint);
      this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
      this.writeTag(tag, Pbf.Varint);
      this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeString(str);
    },
    writeFloatField: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
      this.writeVarintField(tag, Boolean(val));
    }
  };
  function readVarintRemainder(l, s, p) {
    var buf = p.buf, h, b;
    b = buf[p.pos++];
    h = (b & 112) >> 4;
    if (b < 128)
      return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 127) << 3;
    if (b < 128)
      return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 127) << 10;
    if (b < 128)
      return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 127) << 17;
    if (b < 128)
      return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 127) << 24;
    if (b < 128)
      return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 1) << 31;
    if (b < 128)
      return toNum(l, h, s);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function readPackedEnd(pbf2) {
    return pbf2.type === Pbf.Bytes ? pbf2.readVarint() + pbf2.pos : pbf2.pos + 1;
  }
  function toNum(low, high, isSigned) {
    if (isSigned) {
      return high * 4294967296 + (low >>> 0);
    }
    return (high >>> 0) * 4294967296 + (low >>> 0);
  }
  function writeBigVarint(val, pbf2) {
    var low, high;
    if (val >= 0) {
      low = val % 4294967296 | 0;
      high = val / 4294967296 | 0;
    } else {
      low = ~(-val % 4294967296);
      high = ~(-val / 4294967296);
      if (low ^ 4294967295) {
        low = low + 1 | 0;
      } else {
        low = 0;
        high = high + 1 | 0;
      }
    }
    if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
      throw new Error("Given varint doesn't fit into 10 bytes");
    }
    pbf2.realloc(10);
    writeBigVarintLow(low, high, pbf2);
    writeBigVarintHigh(high, pbf2);
  }
  function writeBigVarintLow(low, high, pbf2) {
    pbf2.buf[pbf2.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf2.buf[pbf2.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf2.buf[pbf2.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf2.buf[pbf2.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf2.buf[pbf2.pos] = low & 127;
  }
  function writeBigVarintHigh(high, pbf2) {
    var lsb = (high & 7) << 4;
    pbf2.buf[pbf2.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
    if (!high)
      return;
    pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high)
      return;
    pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high)
      return;
    pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high)
      return;
    pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high)
      return;
    pbf2.buf[pbf2.pos++] = high & 127;
  }
  function makeRoomForExtraLength(startPos, len, pbf2) {
    var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
    pbf2.realloc(extraLen);
    for (var i = pbf2.pos - 1; i >= startPos; i--)
      pbf2.buf[i + extraLen] = pbf2.buf[i];
  }
  function writePackedVarint(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeVarint(arr[i]);
  }
  function writePackedSVarint(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeSVarint(arr[i]);
  }
  function writePackedFloat(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeFloat(arr[i]);
  }
  function writePackedDouble(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeDouble(arr[i]);
  }
  function writePackedBoolean(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeBoolean(arr[i]);
  }
  function writePackedFixed32(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeFixed32(arr[i]);
  }
  function writePackedSFixed32(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeSFixed32(arr[i]);
  }
  function writePackedFixed64(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeFixed64(arr[i]);
  }
  function writePackedSFixed64(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeSFixed64(arr[i]);
  }
  function readUInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
  }
  function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = val >>> 8;
    buf[pos + 2] = val >>> 16;
    buf[pos + 3] = val >>> 24;
  }
  function readInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
  }
  function readUtf8(buf, pos, end) {
    var str = "";
    var i = pos;
    while (i < end) {
      var b0 = buf[i];
      var c = null;
      var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
      if (i + bytesPerSequence > end)
        break;
      var b1, b2, b3;
      if (bytesPerSequence === 1) {
        if (b0 < 128) {
          c = b0;
        }
      } else if (bytesPerSequence === 2) {
        b1 = buf[i + 1];
        if ((b1 & 192) === 128) {
          c = (b0 & 31) << 6 | b1 & 63;
          if (c <= 127) {
            c = null;
          }
        }
      } else if (bytesPerSequence === 3) {
        b1 = buf[i + 1];
        b2 = buf[i + 2];
        if ((b1 & 192) === 128 && (b2 & 192) === 128) {
          c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
          if (c <= 2047 || c >= 55296 && c <= 57343) {
            c = null;
          }
        }
      } else if (bytesPerSequence === 4) {
        b1 = buf[i + 1];
        b2 = buf[i + 2];
        b3 = buf[i + 3];
        if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
          c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
          if (c <= 65535 || c >= 1114112) {
            c = null;
          }
        }
      }
      if (c === null) {
        c = 65533;
        bytesPerSequence = 1;
      } else if (c > 65535) {
        c -= 65536;
        str += String.fromCharCode(c >>> 10 & 1023 | 55296);
        c = 56320 | c & 1023;
      }
      str += String.fromCharCode(c);
      i += bytesPerSequence;
    }
    return str;
  }
  function readUtf8TextDecoder(buf, pos, end) {
    return utf8TextDecoder.decode(buf.subarray(pos, end));
  }
  function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
      c = str.charCodeAt(i);
      if (c > 55295 && c < 57344) {
        if (lead) {
          if (c < 56320) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = c;
            continue;
          } else {
            c = lead - 55296 << 10 | c - 56320 | 65536;
            lead = null;
          }
        } else {
          if (c > 56319 || i + 1 === str.length) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
          } else {
            lead = c;
          }
          continue;
        }
      } else if (lead) {
        buf[pos++] = 239;
        buf[pos++] = 191;
        buf[pos++] = 189;
        lead = null;
      }
      if (c < 128) {
        buf[pos++] = c;
      } else {
        if (c < 2048) {
          buf[pos++] = c >> 6 | 192;
        } else {
          if (c < 65536) {
            buf[pos++] = c >> 12 | 224;
          } else {
            buf[pos++] = c >> 18 | 240;
            buf[pos++] = c >> 12 & 63 | 128;
          }
          buf[pos++] = c >> 6 & 63 | 128;
        }
        buf[pos++] = c & 63 | 128;
      }
    }
    return pos;
  }
  var Pbf$1 = getDefaultExportFromCjs(pbf);
  var GeomType;
  (function(GeomType2) {
    GeomType2[GeomType2["UNKNOWN"] = 0] = "UNKNOWN";
    GeomType2[GeomType2["POINT"] = 1] = "POINT";
    GeomType2[GeomType2["LINESTRING"] = 2] = "LINESTRING";
    GeomType2[GeomType2["POLYGON"] = 3] = "POLYGON";
  })(GeomType || (GeomType = {}));
  function encodeVectorTile(tile) {
    const pbf2 = new Pbf$1();
    for (const id2 in tile.layers) {
      const layer = tile.layers[id2];
      if (!layer.extent) {
        layer.extent = tile.extent;
      }
      pbf2.writeMessage(3, writeLayer, { ...layer, id: id2 });
    }
    return pbf2.finish();
  }
  function writeLayer(layer, pbf2) {
    if (!pbf2)
      throw new Error("pbf undefined");
    pbf2.writeVarintField(15, 2);
    pbf2.writeStringField(1, layer.id || "");
    pbf2.writeVarintField(5, layer.extent || 4096);
    const context = {
      keys: [],
      values: [],
      keycache: {},
      valuecache: {}
    };
    for (const feature of layer.features) {
      context.feature = feature;
      pbf2.writeMessage(2, writeFeature, context);
    }
    for (const key of context.keys) {
      pbf2.writeStringField(3, key);
    }
    for (const value of context.values) {
      pbf2.writeMessage(4, writeValue, value);
    }
  }
  function writeFeature(context, pbf2) {
    const feature = context.feature;
    if (!feature || !pbf2)
      throw new Error();
    pbf2.writeMessage(2, writeProperties, context);
    pbf2.writeVarintField(3, feature.type);
    pbf2.writeMessage(4, writeGeometry, feature);
  }
  function writeProperties(context, pbf2) {
    const feature = context.feature;
    if (!feature || !pbf2)
      throw new Error();
    const keys = context.keys;
    const values = context.values;
    const keycache = context.keycache;
    const valuecache = context.valuecache;
    for (const key in feature.properties) {
      let value = feature.properties[key];
      let keyIndex = keycache[key];
      if (value === null)
        continue;
      if (typeof keyIndex === "undefined") {
        keys.push(key);
        keyIndex = keys.length - 1;
        keycache[key] = keyIndex;
      }
      pbf2.writeVarint(keyIndex);
      const type = typeof value;
      if (type !== "string" && type !== "boolean" && type !== "number") {
        value = JSON.stringify(value);
      }
      const valueKey = `${type}:${value}`;
      let valueIndex = valuecache[valueKey];
      if (typeof valueIndex === "undefined") {
        values.push(value);
        valueIndex = values.length - 1;
        valuecache[valueKey] = valueIndex;
      }
      pbf2.writeVarint(valueIndex);
    }
  }
  function command(cmd, length) {
    return (length << 3) + (cmd & 7);
  }
  function zigzag(num2) {
    return num2 << 1 ^ num2 >> 31;
  }
  function writeGeometry(feature, pbf2) {
    if (!pbf2)
      throw new Error();
    const geometry = feature.geometry;
    const type = feature.type;
    let x = 0;
    let y = 0;
    for (const ring of geometry) {
      let count = 1;
      if (type === GeomType.POINT) {
        count = ring.length / 2;
      }
      pbf2.writeVarint(command(1, count));
      const length = ring.length / 2;
      const lineCount = type === GeomType.POLYGON ? length - 1 : length;
      for (let i = 0; i < lineCount; i++) {
        if (i === 1 && type !== 1) {
          pbf2.writeVarint(command(2, lineCount - 1));
        }
        const dx = ring[i * 2] - x;
        const dy = ring[i * 2 + 1] - y;
        pbf2.writeVarint(zigzag(dx));
        pbf2.writeVarint(zigzag(dy));
        x += dx;
        y += dy;
      }
      if (type === GeomType.POLYGON) {
        pbf2.writeVarint(command(7, 1));
      }
    }
  }
  function writeValue(value, pbf2) {
    if (!pbf2)
      throw new Error();
    if (typeof value === "string") {
      pbf2.writeStringField(1, value);
    } else if (typeof value === "boolean") {
      pbf2.writeBooleanField(7, value);
    } else if (typeof value === "number") {
      if (value % 1 !== 0) {
        pbf2.writeDoubleField(3, value);
      } else if (value < 0) {
        pbf2.writeSVarintField(6, value);
      } else {
        pbf2.writeVarintField(5, value);
      }
    }
  }
  class LocalDemManager {
    constructor(demUrlPattern, cacheSize, encoding, maxzoom, timeoutMs) {
      this.loaded = Promise.resolve();
      this.decodeImage = defaultDecoder;
      this.fetchAndParseTile = (z, x, y, timer) => {
        const self2 = this;
        const url = this.demUrlPattern.replace("{z}", z.toString()).replace("{x}", x.toString()).replace("{y}", y.toString());
        timer === null || timer === void 0 ? void 0 : timer.useTile(url);
        return this.parsedCache.getCancelable(url, () => {
          const tile = self2.fetchTile(z, x, y, timer);
          let canceled = false;
          let alsoCancel = () => {
          };
          return {
            value: tile.value.then(async (response) => {
              if (canceled)
                throw new Error("canceled");
              const result = self2.decodeImage(response.data, self2.encoding);
              alsoCancel = result.cancel;
              const mark = timer === null || timer === void 0 ? void 0 : timer.marker("decode");
              const value = await result.value;
              mark === null || mark === void 0 ? void 0 : mark();
              return value;
            }),
            cancel: () => {
              canceled = true;
              alsoCancel();
              tile.cancel();
            }
          };
        });
      };
      this.tileCache = new AsyncCache(cacheSize);
      this.parsedCache = new AsyncCache(cacheSize);
      this.contourCache = new AsyncCache(cacheSize);
      this.timeoutMs = timeoutMs;
      this.demUrlPattern = demUrlPattern;
      this.encoding = encoding;
      this.maxzoom = maxzoom;
    }
    fetchTile(z, x, y, timer) {
      const url = this.demUrlPattern.replace("{z}", z.toString()).replace("{x}", x.toString()).replace("{y}", y.toString());
      timer === null || timer === void 0 ? void 0 : timer.useTile(url);
      return this.tileCache.getCancelable(url, () => {
        let cancel = () => {
        };
        const options = {};
        try {
          const controller = new AbortController();
          options.signal = controller.signal;
          cancel = () => controller.abort();
        } catch (e) {
        }
        timer === null || timer === void 0 ? void 0 : timer.fetchTile(url);
        const mark = timer === null || timer === void 0 ? void 0 : timer.marker("fetch");
        return withTimeout(this.timeoutMs, {
          value: fetch(url, options).then(async (response) => {
            mark === null || mark === void 0 ? void 0 : mark();
            if (!response.ok) {
              throw new Error(`Bad response: ${response.status} for ${url}`);
            }
            return {
              data: await response.blob(),
              expires: response.headers.get("expires") || void 0,
              cacheControl: response.headers.get("cache-control") || void 0
            };
          }),
          cancel
        });
      });
    }
    fetchDem(z, x, y, options, timer) {
      const zoom = Math.min(z - (options.overzoom || 0), this.maxzoom);
      const subZ = z - zoom;
      const div = 1 << subZ;
      const newX = Math.floor(x / div);
      const newY = Math.floor(y / div);
      const { value, cancel } = this.fetchAndParseTile(zoom, newX, newY, timer);
      const subX = x % div;
      const subY = y % div;
      return {
        value: value.then((tile) => HeightTile.fromRawDem(tile).split(subZ, subX, subY)),
        cancel
      };
    }
    fetchContourTile(z, x, y, options, timer) {
      const { levels, multiplier = 1, buffer = 1, extent = 4096, contourLayer = "contours", elevationKey = "ele", levelKey = "level", subsampleBelow = 100 } = options;
      if (!levels || levels.length === 0) {
        return {
          cancel() {
          },
          value: Promise.resolve({ arrayBuffer: new ArrayBuffer(0) })
        };
      }
      const key = [z, x, y, encodeIndividualOptions(options)].join("/");
      return this.contourCache.getCancelable(key, () => {
        const max = 1 << z;
        let canceled = false;
        const neighborPromises = [];
        for (let iy = y - 1; iy <= y + 1; iy++) {
          for (let ix = x - 1; ix <= x + 1; ix++) {
            neighborPromises.push(iy < 0 || iy >= max ? null : this.fetchDem(z, (ix + max) % max, iy, options, timer));
          }
        }
        const value = Promise.all(neighborPromises.map((n) => n === null || n === void 0 ? void 0 : n.value)).then(async (neighbors) => {
          let virtualTile = HeightTile.combineNeighbors(neighbors);
          if (!virtualTile || canceled) {
            return { arrayBuffer: new Uint8Array().buffer };
          }
          const mark = timer === null || timer === void 0 ? void 0 : timer.marker("isoline");
          if (virtualTile.width >= subsampleBelow) {
            virtualTile = virtualTile.materialize(2);
          } else {
            while (virtualTile.width < subsampleBelow) {
              virtualTile = virtualTile.subsamplePixelCenters(2).materialize(2);
            }
          }
          virtualTile = virtualTile.averagePixelCentersToGrid().scaleElevation(multiplier).materialize(1);
          const isolines = generateIsolines(levels[0], virtualTile, extent, buffer);
          mark === null || mark === void 0 ? void 0 : mark();
          const result = encodeVectorTile({
            extent,
            layers: {
              [contourLayer]: {
                features: Object.entries(isolines).map(([eleString, geom]) => {
                  const ele = Number(eleString);
                  return {
                    type: GeomType.LINESTRING,
                    geometry: geom,
                    properties: {
                      [elevationKey]: ele,
                      [levelKey]: Math.max(...levels.map((l, i) => ele % l === 0 ? i : 0))
                    }
                  };
                })
              }
            }
          });
          mark === null || mark === void 0 ? void 0 : mark();
          return { arrayBuffer: result.buffer };
        });
        return {
          value,
          cancel() {
            canceled = true;
            neighborPromises.forEach((n) => n && n.cancel());
          }
        };
      });
    }
  }
  const perf = typeof performance !== "undefined" ? performance : void 0;
  const timeOrigin = perf ? perf.timeOrigin || (/* @__PURE__ */ new Date()).getTime() - perf.now() : (/* @__PURE__ */ new Date()).getTime();
  function getResourceTiming(url) {
    var _a;
    return JSON.parse(JSON.stringify(((_a = perf === null || perf === void 0 ? void 0 : perf.getEntriesByName) === null || _a === void 0 ? void 0 : _a.call(perf, url)) || []));
  }
  function now() {
    return perf ? perf.now() : (/* @__PURE__ */ new Date()).getTime();
  }
  function flatten(input) {
    const result = [];
    for (const list of input) {
      result.push(...list);
    }
    return result;
  }
  class Timer {
    constructor(name) {
      this.marks = {};
      this.urls = [];
      this.fetched = [];
      this.resources = [];
      this.tilesFetched = 0;
      this.timeOrigin = timeOrigin;
      this.finish = (url) => {
        this.markFinish();
        const get = (type) => {
          const all = this.marks[type] || [];
          const max = Math.max(...all.map((ns) => Math.max(...ns)));
          const min = Math.min(...all.map((ns) => Math.min(...ns)));
          return Number.isFinite(max) ? max - min : void 0;
        };
        const duration = get("main") || 0;
        const fetch2 = get("fetch");
        const decode = get("decode");
        const process = get("isoline");
        return {
          url,
          tilesUsed: this.tilesFetched,
          origin: this.timeOrigin,
          marks: this.marks,
          resources: [
            ...this.resources,
            ...flatten(this.fetched.map(getResourceTiming))
          ],
          duration,
          fetch: fetch2,
          decode,
          process,
          wait: duration - (fetch2 || 0) - (decode || 0) - (process || 0)
        };
      };
      this.error = (url) => ({ ...this.finish(url), error: true });
      this.marker = (category) => {
        var _a;
        if (!this.marks[category]) {
          this.marks[category] = [];
        }
        const marks = [now()];
        (_a = this.marks[category]) === null || _a === void 0 ? void 0 : _a.push(marks);
        return () => marks.push(now());
      };
      this.useTile = (url) => {
        if (this.urls.indexOf(url) < 0) {
          this.urls.push(url);
          this.tilesFetched++;
        }
      };
      this.fetchTile = (url) => {
        if (this.fetched.indexOf(url) < 0) {
          this.fetched.push(url);
        }
      };
      this.addAll = (timings) => {
        var _a;
        this.tilesFetched += timings.tilesUsed;
        const offset = timings.origin - this.timeOrigin;
        for (const category in timings.marks) {
          const key = category;
          const ourList = this.marks[key] || (this.marks[key] = []);
          ourList.push(...((_a = timings.marks[key]) === null || _a === void 0 ? void 0 : _a.map((ns) => ns.map((n) => n + offset))) || []);
        }
        this.resources.push(...timings.resources.map((rt) => applyOffset(rt, offset)));
      };
      this.markFinish = this.marker(name);
    }
  }
  const startOrEnd = /(Start$|End$|^start|^end)/;
  function applyOffset(obj, offset) {
    const result = {};
    for (const key in obj) {
      if (obj[key] !== 0 && startOrEnd.test(key)) {
        result[key] = Number(obj[key]) + offset;
      } else {
        result[key] = obj[key];
      }
    }
    return result;
  }
  let id = 0;
  class Actor {
    constructor(dest, dispatcher, timeoutMs = 2e4) {
      this.callbacks = {};
      this.cancels = {};
      this.dest = dest;
      this.timeoutMs = timeoutMs;
      this.dest.onmessage = async ({ data }) => {
        const message = data;
        if (message.type === "cancel") {
          const cancel = this.cancels[message.id];
          delete this.cancels[message.id];
          if (cancel) {
            cancel();
          }
        } else if (message.type === "response") {
          const callback = this.callbacks[message.id];
          delete this.callbacks[message.id];
          if (callback) {
            callback(message.error ? new Error(message.error) : void 0, message.response, message.timings);
          }
        } else if (message.type === "request") {
          const timer = new Timer("worker");
          const handler = dispatcher[message.name];
          const request = handler.apply(handler, [...message.args, timer]);
          const url = `${message.name}_${message.id}`;
          if (message.id && request) {
            this.cancels[message.id] = request.cancel;
            try {
              const response = await request.value;
              const transferrables = response === null || response === void 0 ? void 0 : response.transferrables;
              this.postMessage({
                id: message.id,
                type: "response",
                response,
                timings: timer.finish(url)
              }, transferrables);
            } catch (e) {
              this.postMessage({
                id: message.id,
                type: "response",
                error: (e === null || e === void 0 ? void 0 : e.toString()) || "error",
                timings: timer.finish(url)
              });
            }
            delete this.cancels[message.id];
          }
        }
      };
    }
    postMessage(message, transferrables) {
      this.dest.postMessage(message, transferrables || []);
    }
    /** Invokes a method by name with a set of arguments in the remote context. */
    send(name, transferrables, timer, ...args) {
      const thisId = ++id;
      const value = new Promise((resolve, reject) => {
        this.postMessage({ id: thisId, type: "request", name, args }, transferrables);
        this.callbacks[thisId] = (error, result, timings) => {
          timer === null || timer === void 0 ? void 0 : timer.addAll(timings);
          if (error)
            reject(error);
          else
            resolve(result);
        };
      });
      return withTimeout(this.timeoutMs, {
        value,
        cancel: () => {
          delete this.callbacks[thisId];
          this.postMessage({ id: thisId, type: "cancel" });
        }
      });
    }
  }
  exports.Actor = Actor;
  exports.HeightTile = HeightTile;
  exports.LocalDemManager = LocalDemManager;
  exports.Timer = Timer;
  exports.decodeOptions = decodeOptions;
  exports.decodeParsedImage = decodeParsedImage;
  exports.defaultDecoder = defaultDecoder;
  exports.encodeOptions = encodeOptions;
  exports.generateIsolines = generateIsolines;
  exports.getOptionsForZoom = getOptionsForZoom;
  exports.prepareContourTile = prepareContourTile;
  exports.prepareDemTile = prepareDemTile;
});
define(["./shared"], function(actor) {
  "use strict";
  const noManager = (managerId) => ({
    cancel() {
    },
    value: Promise.reject(new Error(`No manager registered for ${managerId}`))
  });
  class WorkerDispatch {
    constructor() {
      this.managers = {};
      this.init = (message) => {
        this.managers[message.managerId] = new actor.LocalDemManager(message.demUrlPattern, message.cacheSize, message.encoding, message.maxzoom, message.timeoutMs);
        return { cancel() {
        }, value: Promise.resolve() };
      };
      this.fetchTile = (managerId, z, x, y, timer) => {
        var _a;
        return ((_a = this.managers[managerId]) === null || _a === void 0 ? void 0 : _a.fetchTile(z, x, y, timer)) || noManager(managerId);
      };
      this.fetchAndParseTile = (managerId, z, x, y, timer) => {
        var _a;
        return actor.prepareDemTile(((_a = this.managers[managerId]) === null || _a === void 0 ? void 0 : _a.fetchAndParseTile(z, x, y, timer)) || noManager(managerId), true);
      };
      this.fetchContourTile = (managerId, z, x, y, options, timer) => {
        var _a;
        return actor.prepareContourTile(((_a = this.managers[managerId]) === null || _a === void 0 ? void 0 : _a.fetchContourTile(z, x, y, options, timer)) || noManager(managerId));
      };
    }
  }
  const g = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  g.actor = new actor.Actor(g, new WorkerDispatch());
});
define(["./shared"], function(actor) {
  "use strict";
  const CONFIG = { workerUrl: "" };
  let _actor;
  let id = 0;
  class MainThreadDispatch {
    constructor() {
      this.decodeImage = (blob, encoding) => actor.prepareDemTile(actor.defaultDecoder(blob, encoding), false);
    }
  }
  function defaultActor() {
    if (!_actor) {
      const worker2 = new Worker(CONFIG.workerUrl);
      const dispatch = new MainThreadDispatch();
      _actor = new actor.Actor(worker2, dispatch);
    }
    return _actor;
  }
  class RemoteDemManager {
    constructor(demUrlPattern, cacheSize, encoding, maxzoom, timeoutMs, actor2) {
      this.fetchTile = (z, x, y, timer) => this.actor.send("fetchTile", [], timer, this.managerId, z, x, y);
      this.fetchAndParseTile = (z, x, y, timer) => this.actor.send("fetchAndParseTile", [], timer, this.managerId, z, x, y);
      this.fetchContourTile = (z, x, y, options, timer) => this.actor.send("fetchContourTile", [], timer, this.managerId, z, x, y, options);
      const managerId = this.managerId = ++id;
      this.actor = actor2 || defaultActor();
      this.loaded = this.actor.send("init", [], void 0, {
        cacheSize,
        demUrlPattern,
        encoding,
        maxzoom,
        managerId,
        timeoutMs
      }).value;
    }
  }
  if (!Blob.prototype.arrayBuffer) {
    Blob.prototype.arrayBuffer = function arrayBuffer() {
      return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        fileReader.onload = (event) => {
          var _a;
          return resolve((_a = event.target) === null || _a === void 0 ? void 0 : _a.result);
        };
        fileReader.onerror = reject;
        fileReader.readAsArrayBuffer(this);
      });
    };
  }
  const used = /* @__PURE__ */ new Set();
  class DemSource {
    constructor({ url, cacheSize = 100, id: id2 = "dem", encoding = "terrarium", maxzoom = 12, worker: worker2 = true, timeoutMs = 1e4, actor: actor$1 }) {
      this.timingCallbacks = [];
      this.onTiming = (callback) => {
        this.timingCallbacks.push(callback);
      };
      this.setupMaplibre = (maplibre) => {
        maplibre.addProtocol(this.sharedDemProtocolId, this.sharedDemProtocol);
        maplibre.addProtocol(this.contourProtocolId, this.contourProtocol);
      };
      this.sharedDemProtocol = (request, response) => {
        const [z, x, y] = this.parseUrl(request.url);
        const timer = new actor.Timer("main");
        const result = this.manager.fetchTile(z, x, y, timer);
        let canceled = false;
        (async () => {
          let timing;
          try {
            const data = await result.value;
            timing = timer.finish(request.url);
            if (canceled)
              return;
            const arrayBuffer = await data.data.arrayBuffer();
            if (canceled)
              return;
            response(void 0, arrayBuffer, data.cacheControl, data.expires);
          } catch (error) {
            timing = timer.error(request.url);
            if (canceled)
              return;
            response(error);
          }
          this.timingCallbacks.forEach((cb) => cb(timing));
        })();
        return {
          cancel: () => {
            canceled = false;
            result.cancel();
          }
        };
      };
      this.contourProtocol = (request, response) => {
        const timer = new actor.Timer("main");
        const [z, x, y] = this.parseUrl(request.url);
        const options = actor.decodeOptions(request.url);
        const result = this.manager.fetchContourTile(z, x, y, actor.getOptionsForZoom(options, z), timer);
        let canceled = false;
        (async () => {
          let timing;
          try {
            const data = await result.value;
            timing = timer.finish(request.url);
            if (canceled)
              return;
            response(void 0, data.arrayBuffer);
          } catch (error) {
            if (canceled)
              return;
            timing = timer.error(request.url);
            response(error);
          }
          this.timingCallbacks.forEach((cb) => cb(timing));
        })();
        return {
          cancel: () => {
            canceled = true;
            result.cancel();
          }
        };
      };
      this.contourProtocolUrl = (options) => `${this.contourProtocolUrlBase}?${actor.encodeOptions(options)}`;
      let protocolPrefix = id2;
      let i = 1;
      while (used.has(protocolPrefix)) {
        protocolPrefix = id2 + i++;
      }
      used.add(protocolPrefix);
      this.sharedDemProtocolId = `${protocolPrefix}-shared`;
      this.contourProtocolId = `${protocolPrefix}-contour`;
      this.sharedDemProtocolUrl = `${this.sharedDemProtocolId}://{z}/{x}/{y}`;
      this.contourProtocolUrlBase = `${this.contourProtocolId}://{z}/{x}/{y}`;
      const ManagerClass = worker2 ? RemoteDemManager : actor.LocalDemManager;
      this.manager = new ManagerClass(url, cacheSize, encoding, maxzoom, timeoutMs, actor$1);
    }
    getDemTile(z, x, y) {
      return this.manager.fetchAndParseTile(z, x, y).value;
    }
    parseUrl(url) {
      const [, z, x, y] = /\/\/(\d+)\/(\d+)\/(\d+)/.exec(url) || [];
      return [Number(z), Number(x), Number(y)];
    }
  }
  const exported = {
    generateIsolines: actor.generateIsolines,
    DemSource,
    HeightTile: actor.HeightTile,
    LocalDemManager: actor.LocalDemManager,
    decodeParsedImage: actor.decodeParsedImage,
    set workerUrl(url) {
      CONFIG.workerUrl = url;
    },
    get workerUrl() {
      return CONFIG.workerUrl;
    }
  };
  return exported;
});
var mlcontour$1 = mlcontour;
export {
  mlcontour$1 as default
};
/*! Bundled license information:

maplibre-contour/dist/index.mjs:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=maplibre-contour.js.map
