define(['./shared'], (function (actor) { 'use strict';

const CONFIG = { workerUrl: "" };

let _actor;
let id = 0;
class MainThreadDispatch {
    constructor() {
        this.decodeImage = (blob, encoding) => actor.prepareDemTile(actor.defaultDecoder(blob, encoding), false);
    }
}
function defaultActor() {
    if (!_actor) {
        const worker = new Worker(CONFIG.workerUrl);
        const dispatch = new MainThreadDispatch();
        _actor = new actor.Actor(worker, dispatch);
    }
    return _actor;
}
/**
 * Caches, decodes, and processes raster tiles in a shared web worker.
 */
class RemoteDemManager {
    constructor(demUrlPattern, cacheSize, encoding, maxzoom, timeoutMs, actor) {
        this.fetchTile = (z, x, y, timer) => this.actor.send("fetchTile", [], timer, this.managerId, z, x, y);
        this.fetchAndParseTile = (z, x, y, timer) => this.actor.send("fetchAndParseTile", [], timer, this.managerId, z, x, y);
        this.fetchContourTile = (z, x, y, options, timer) => this.actor.send("fetchContourTile", [], timer, this.managerId, z, x, y, options);
        const managerId = (this.managerId = ++id);
        this.actor = actor || defaultActor();
        this.loaded = this.actor.send("init", [], undefined, {
            cacheSize,
            demUrlPattern,
            encoding,
            maxzoom,
            managerId,
            timeoutMs,
        }).value;
    }
}

if (!Blob.prototype.arrayBuffer) {
    Blob.prototype.arrayBuffer = function arrayBuffer() {
        return new Promise((resolve, reject) => {
            const fileReader = new FileReader();
            fileReader.onload = (event) => { var _a; return resolve((_a = event.target) === null || _a === void 0 ? void 0 : _a.result); };
            fileReader.onerror = reject;
            fileReader.readAsArrayBuffer(this);
        });
    };
}
const used = new Set();
/**
 * A remote source of DEM tiles that can be connected to maplibre.
 */
class DemSource {
    constructor({ url, cacheSize = 100, id = "dem", encoding = "terrarium", maxzoom = 12, worker = true, timeoutMs = 10000, actor: actor$1, }) {
        this.timingCallbacks = [];
        /** Registers a callback to be invoked with a performance report after each tile is requested. */
        this.onTiming = (callback) => {
            this.timingCallbacks.push(callback);
        };
        /**
         * Adds contour and shared DEM protocol handlers to maplibre.
         *
         * @param maplibre maplibre global object
         */
        this.setupMaplibre = (maplibre) => {
            maplibre.addProtocol(this.sharedDemProtocolId, this.sharedDemProtocol);
            maplibre.addProtocol(this.contourProtocolId, this.contourProtocol);
        };
        /**
         * Callback to be used with maplibre addProtocol to re-use cached DEM tiles across sources.
         */
        this.sharedDemProtocol = (request, response) => {
            const [z, x, y] = this.parseUrl(request.url);
            const timer = new actor.Timer("main");
            const result = this.manager.fetchTile(z, x, y, timer);
            let canceled = false;
            (async () => {
                let timing;
                try {
                    const data = await result.value;
                    timing = timer.finish(request.url);
                    if (canceled)
                        return;
                    const arrayBuffer = await data.data.arrayBuffer();
                    if (canceled)
                        return;
                    response(undefined, arrayBuffer, data.cacheControl, data.expires);
                }
                catch (error) {
                    timing = timer.error(request.url);
                    if (canceled)
                        return;
                    response(error);
                }
                this.timingCallbacks.forEach((cb) => cb(timing));
            })();
            return {
                cancel: () => {
                    canceled = false;
                    result.cancel();
                },
            };
        };
        /**
         * Callback to be used with maplibre addProtocol to generate contour vector tiles according
         * to options encoded in the tile URL pattern generated by `contourProtocolUrl`.
         */
        this.contourProtocol = (request, response) => {
            const timer = new actor.Timer("main");
            const [z, x, y] = this.parseUrl(request.url);
            const options = actor.decodeOptions(request.url);
            const result = this.manager.fetchContourTile(z, x, y, actor.getOptionsForZoom(options, z), timer);
            let canceled = false;
            (async () => {
                let timing;
                try {
                    const data = await result.value;
                    timing = timer.finish(request.url);
                    if (canceled)
                        return;
                    response(undefined, data.arrayBuffer);
                }
                catch (error) {
                    if (canceled)
                        return;
                    timing = timer.error(request.url);
                    response(error);
                }
                this.timingCallbacks.forEach((cb) => cb(timing));
            })();
            return {
                cancel: () => {
                    canceled = true;
                    result.cancel();
                },
            };
        };
        /**
         * Returns a URL with the correct maplibre protocol prefix and all `option` encoded in request parameters.
         */
        this.contourProtocolUrl = (options) => `${this.contourProtocolUrlBase}?${actor.encodeOptions(options)}`;
        let protocolPrefix = id;
        let i = 1;
        while (used.has(protocolPrefix)) {
            protocolPrefix = id + i++;
        }
        used.add(protocolPrefix);
        this.sharedDemProtocolId = `${protocolPrefix}-shared`;
        this.contourProtocolId = `${protocolPrefix}-contour`;
        this.sharedDemProtocolUrl = `${this.sharedDemProtocolId}://{z}/{x}/{y}`;
        this.contourProtocolUrlBase = `${this.contourProtocolId}://{z}/{x}/{y}`;
        const ManagerClass = worker ? RemoteDemManager : actor.LocalDemManager;
        this.manager = new ManagerClass(url, cacheSize, encoding, maxzoom, timeoutMs, actor$1);
    }
    getDemTile(z, x, y) {
        return this.manager.fetchAndParseTile(z, x, y).value;
    }
    parseUrl(url) {
        const [, z, x, y] = /\/\/(\d+)\/(\d+)\/(\d+)/.exec(url) || [];
        return [Number(z), Number(x), Number(y)];
    }
}

const exported = {
    generateIsolines: actor.generateIsolines,
    DemSource,
    HeightTile: actor.HeightTile,
    LocalDemManager: actor.LocalDemManager,
    decodeParsedImage: actor.decodeParsedImage,
    set workerUrl(url) {
        CONFIG.workerUrl = url;
    },
    get workerUrl() {
        return CONFIG.workerUrl;
    },
};

return exported;

}));
